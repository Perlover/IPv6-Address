<html><head><title>IPv6::Address</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.28,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.020001 at Sun Apr 19 21:57:00 2015 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<h1><a class='u'
name="NAME"
>NAME</a></h1>

<p>IPv6::Address - IPv6 Address Manipulation Library</p>

<h1><a class='u'
name="VERSION"
>VERSION</a></h1>

<p>version 0.1</p>

<h1><a class='u'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre> use IPv6::Address;

 my $ipv6 = IPv6::Address-&#62;new(&#39;2001:648:2000::/48&#39;);

 $ipv6-&#62;contains(&#39;2001:648:2000::/64&#39;); #true

 say $ipv6-&#62;to_string;
 say $ipv6-&#62;string; # Same as previous
 say $ipv6; # Same as previous

 say $ipv6-&#62;string(nocompress=&#62;1); # do not compress using the :: notation
 say $ipv6-&#62;string(ipv4=&#62;1); #print the last 32 bits as an IPv4 address
 
 $ipv6-&#62;addr_string; # Returns &#39;2001:648:2000::&#39;
 
 $ipv6-&#62;split(4); # Split the prefix into 2^4 smaller prefixes. Returns a list.
 
 $ipv6-&#62;apply_mask; # Apply the mask to the address. All bits beyond the mask length become 0.

 $ipv6-&#62;first_address;

 $ipv6-&#62;last_address;

 $a-&#62;enumerate_with_offset( 5 , 64 ); #returns 2001:648:2000:4::/64 </pre>

<h1><a class='u'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>A pure Perl IPv6 address manipulation library. Emphasis on manipulation of prefixes and addresses. Very easy to understand and modify. The internal representation of an IPv6::Address is a blessed hash with two keys, a prefix length (0-128 obviously) and a 128-bit string. A multitude of methods to do various tasks is provided.</p>

<h2><a class='u'
name="Methods"
>Methods</a></h2>

<dl>
<dt><a name="new(_ipv6_string_)"
><code>new( ipv6_string )</code></a></dt>

<dd>
<p>Takes a string representation of an IPv6 address and creates a corresponding IPv6::Address object.</p>

<dt><a name="raw_new(_bitstr,_length_)"
><code>raw_new( bitstr, length )</code></a></dt>

<dd>
<p>Creates a new IPv6::Address out of a bitstring and a prefix length. The bitstring must be binary, please do not use a &#39;0&#39; or &#39;1&#39; character string.</p>

<dt><a name="get_bitstr"
><code>get_bitstr</code></a></dt>

<dd>
<p>Returns the bitstr of the object.</p>

<dt><a name="get_prefixlen"
><code>get_prefixlen</code></a></dt>

<dd>
<p>Returns the prefix length of the address.</p>

<dt><a name="get_mask_bitstr(length)"
><code>get_mask_bitstr(length)</code></a></dt>

<dd>
<p>Returns a 128-bit string with the first prefix-length bits equal to 1, rest equal to 0. Essentially takes the prefix length of the object and returns a corresponding bit mask.</p>

<dt><a name="get_masked_address_bitstr"
><code>get_masked_address_bitstr</code></a></dt>

<dd>
<p>Returns the bitstring, after zeroing out all the bits after the prefix length. Essentially applies the prefix mask to the address.</p>

<dt><a name="generate_bitstr(_number_)"
><code>generate_bitstr( number )</code></a></dt>

<dd>
<p>Not a method, returns 128-bit string, first n-items are 1, rest is 0.</p>

<dt><a name="bitstr_and(_bitstr1_,_bitstr2_)"
><code>bitstr_and( bitstr1 , bitstr2 )</code></a></dt>

<dd>
<p>Not a method, AND&#39;s two bitstrings, returns result.</p>

<dt><a name="bitstr_or(_bitstr1_,_bitstr2)"
><code>bitstr_or( bitstr1 , bitstr2)</code></a></dt>

<dd>
<p>Not a method, OR&#39;s two bitstrings, returns result.</p>

<dt><a name="bitstr_not(_bitstr_)"
><code>bitstr_not( bitstr )</code></a></dt>

<dd>
<p>Not a method, inverts a bitstring.</p>

<dt><a name="from_str(_string_bitstring_)"
><code>from_str( string_bitstring )</code></a></dt>

<dd>
<p>Not a method, takes a string of characters 0 or 1, returns corresponding binary bitstring. Please do not use more than 128 characters, rest will be ignored.</p>

<dt><a name="to_str(_bitstring_)"
><code>to_str( bitstring )</code></a></dt>

<dd>
<p>Not a method, takes a binary bitstring, returns a string composed of 0&#39;s and 1&#39;s. Please supply bitstrings of max. 128 bits, rest of the bits will be ignored.</p>

<dt><a name="contains(_other_address_)"
><code>contains( other_address )</code></a></dt>

<dd>
<p>This method takes an argument which is either an IPv6::Address or a plain string that can be promoted to a valid IPv6::Address, and tests whether the object contains it. Obviously returns true or false.</p>

<dt><a name="addr_string"
><code>addr_string</code></a></dt>

<dd>
<p>Returns the address part of the IPv6::Address. Using the option ipv4=&#62;1 like</p>

<pre> $a-&#62;addr_string(ipv4=&#62;1) </pre>

<p>will make the last 32-bits appear as an IPv4 address. Also, using nocompress=1 like</p>

<pre> $a-&#62;addr_string(nocompress=1) </pre>

<p>will prevent the string from containing a &#39;::&#39; part. So it will be 8 parts separated by &#39;:&#39; colons.</p>

<dt><a name="string"
><code>string</code></a></dt>

<dd>
<p>Returns the full IPv6 address, with the prefix in its end.</p>

<dt><a name="to_string"
><code>to_string</code></a></dt>

<dd>
<p>Used internally by the overload module.</p>

<dt><a name="split(_exponent_,_target_length_)"
><code>split( exponent , target_length )</code></a></dt>

<dd>
<p>Splits the address to the order of two of the number given as first argument. Example: if argument is 3, 2^3=8, address is split into 8 parts. The final parts have prefix length equal to the target_length specified in the second argument.</p>

<dt><a name="apply_mask"
><code>apply_mask</code></a></dt>

<dd>
<p>Applies the prefix length mask to the address. Does not return anything. Works on $self. <b>WARNING:</b>This will alter the object.</p>

<dt><a name="first_address"
><code>first_address</code></a></dt>

<dd>
<p>Returns the first address of the prefix that is represented by the object. E.g. consider 2001:648:2000::1234/64. First address will be 2001:648:2000::/64.</p>

<dt><a name="last_address"
><code>last_address</code></a></dt>

<dd>
<p>Returns the last address of the prefix that is represented by the object. E.g. consider 2001:648:2000::1234/64. Last address will be 2001:648:2000::ffff:ffff:ffff:ffff/64.</p>

<dt><a name="is_unspecified_,_is_loopback_,_is_multicast"
><code>is_unspecified</code> , <code>is_loopback</code> , <code>is_multicast</code></a></dt>

<dd>
<p>Returns true or false depending on whether the address falls into the corresponding category stated by the method name. E.g.</p>

<pre> IPv6::Address-&#62;new(&#39;::1&#39;)-&#62;is_loopback # returns true</pre>

<dt><a name="ipv4_to_binarray"
><code>ipv4_to_binarray</code></a></dt>

<dd>
<p>Not a method, takes an IPv4 address, returns a character string consisting of 32 characters that are 0 or 1. Used internally, not too useful for the end user.</p>

<dt><a name="enumerate_with_IPv4(_ipv4,_mask_)"
><code>enumerate_with_IPv4( ipv4, mask )</code></a></dt>

<dd>
<p>Takes an IPv4 address and uses a part of it to enumerate inside the Ipv6 prefix of the object. E.g.</p>

<pre> IPv6::Address-&#62;new(&#39;2001:648:2001::/48&#39;)-&#62;enumerate_with_IPv4(&#39;0.0.0.1&#39;,0x0000ffff) #will yield 2001:648::2001:0001::/64</pre>

<p>The return value will be a new IPv6::Address object, so the original object remains intact. The part that will be used as an offset is extracted from the ipv4 by using the mask.</p>

<dt><a name="enumerate_with_offset(_offset,_desired_length_)"
><code>enumerate_with_offset( offset, desired_length )</code></a></dt>

<dd>
<p>Takes a non-negative integer offset and returns a prefix whose relative position inside the object is defined by the offset. The prefix length of the result is defined by the second argument. E.g.</p>

<pre> IPv6::Address-&#62;new(&#39;2001:648:2000::/48&#39;)-&#62;enumerate_with_offset( 5 , 64 ) #2001:648:2000:4::/64</pre>

<dt><a name="increment(_offset_)"
><code>increment( offset )</code></a></dt>

<dd>
<p>Increments the IPv6::Address object by offset. Offsets larger than 2^32-1 are not acceptable. This method is probably not too useful, but is provided for completeness.</p>

<dt><a name="nxx_parts(unpack_format)"
><code>nxx_parts(unpack_format)</code></a></dt>

<dd>
<p>Takes the bitstring of the address and unpacks it using the first argument. Internal use mostly.</p>

<dt><a name="n16_parts"
><code>n16_parts</code></a></dt>

<dd>
<p>Splits the address into an 8-item array of unsigned short integers. Network byte order is implied, a short integer is 16-bits long.</p>

<dt><a name="n16_parts"
><code>n16_parts</code></a></dt>

<dd>
<p>Splits the address into an 4-item array of unsigned long integers. Network byte order is implied, a long integer is 32-bits long.</p>

<dt><a name="n_cmp(_a_,_b_)"
><code>n_cmp( a , b )</code></a></dt>

<dd>
<p>Takes two 128-bit bitstr arguments, compares them and returns the result as -1, 0 or 1. The semantics are the same as that of the spaceship operator &#60;=&#62;.</p>

<p>This method will overload the &#60;=&#62; operator for IPv6::Address objects, so comparing IPv6::Address objects like they were integers produces the correct results.</p>

<dt><a name="n_sort(_array_)"
><code>n_sort( array )</code></a></dt>

<dd>
<p>Sorts an array of bitstrs using the n_cmp function.</p>

<dt><a name="radius_string"
><code>radius_string</code></a></dt>

<dd>
<p>Returns a string suitable to be returned as an IPv6 Radius AV-pair. See RFC 3162 for an explanation of the format.</p>
</dd>
</dl>

<h1><a class='u'
name="NAME"
>NAME</a></h1>

<p>IPv6::Address - IPv6 Address Manipulation Library</p>

<img src="https://travis-ci.org/aduitsis/IPv6-Address.svg?branch=master">


<h1><a class='u'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Athanasios Douitsis <code>&#60;aduitsis@cpan.org&#62;</code></p>

<h1><a class='u'
name="SUPPORT"
>SUPPORT</a></h1>

<p>Please open a ticket at <a href="https://github.com/aduitsis/IPv6-Address" class="podlinkurl"
>https://github.com/aduitsis/IPv6-Address</a>.</p>

<h1><a class='u'
name="COPYRIGHT_&#38;_LICENSE"
>COPYRIGHT &#38; LICENSE</a></h1>

<p>Copyright 2008-2015 Athanasios Douitsis, all rights reserved.</p>

<p>This program is free software; you can use it under the terms of Artistic License 2.0 which can be found at http://www.perlfoundation.org/artistic_license_2_0</p>

<h1><a class='u'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Athanasios Douitsis &#60;aduitsis@cpan.org&#62;</p>

<h1><a class='u'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>This software is Copyright (c) 2015 by Athanasios Douitsis.</p>

<p>This is free software, licensed under:</p>

<pre>  The Artistic License 2.0 (GPL Compatible)</pre>

<!-- end doc -->

</body></html>
